Committer: Dmitrii Okunev

--- /dev/null
+++ dwm-6.4/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "cstdlib": "cpp"
+    }
+}
\ No newline at end of file
--- /dev/null
+++ dwm-6.4/accessnthmon.diff
@@ -0,0 +1,100 @@
+diff --git a/config.def.h b/config.def.h
+index 1c0b587..8595a71 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -49,7 +49,10 @@ static const Layout layouts[] = {
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+-	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
++	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
++        { ALTMOD,                       KEY,      focusnthmon,    {.i  = TAG } }, \
++        { ALTMOD|ShiftMask,             KEY,      tagnthmon,      {.i  = TAG } },
++
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+diff --git a/dwm.c b/dwm.c
+index b0b3466..96fa0bd 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -161,6 +161,7 @@ static void destroynotify(XEvent *e);
+ static void detach(Client *c);
+ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
++static Monitor *numtomon(int num);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static void enternotify(XEvent *e);
+@@ -168,6 +169,7 @@ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+ static void focusmon(const Arg *arg);
++static void focusnthmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+ static Atom getatomprop(Client *c, Atom prop);
+ static int getrootptr(int *x, int *y);
+@@ -209,6 +211,7 @@ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
++static void tagnthmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+@@ -693,6 +696,18 @@ dirtomon(int dir)
+ 	return m;
+ }
+ 
++Monitor *
++numtomon(int num)
++{
++	Monitor *m = NULL;
++	int i = 0;
++
++	for(m = mons, i=0; m->next && i < num; m = m->next){
++		i++;
++	}
++	return m;
++}
++
+ void
+ drawbar(Monitor *m)
+ {
+@@ -830,6 +845,21 @@ focusmon(const Arg *arg)
+ 	focus(NULL);
+ }
+ 
++void
++focusnthmon(const Arg *arg)
++{
++	Monitor *m;
++
++	if (!mons->next)
++		return;
++
++	if ((m = numtomon(arg->i)) == selmon)
++		return;
++	unfocus(selmon->sel, 0);
++	selmon = m;
++	focus(NULL);
++}
++
+ void
+ focusstack(const Arg *arg)
+ {
+@@ -1671,6 +1701,14 @@ tagmon(const Arg *arg)
+ 	sendmon(selmon->sel, dirtomon(arg->i));
+ }
+ 
++void
++tagnthmon(const Arg *arg)
++{
++	if (!selmon->sel || !mons->next)
++		return;
++	sendmon(selmon->sel, numtomon(arg->i));
++}
++
+ void
+ tile(Monitor *m)
+ {
--- dwm-6.4.orig/config.def.h
+++ dwm-6.4/config.def.h
@@ -5,8 +5,8 @@ static const unsigned int borderpx  = 1;
 static const unsigned int snap      = 32;       /* snap pixel */
 static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
+static const char *fonts[]          = { "monospace:size=28" };
+static const char dmenufont[]       = "monospace:size=28";
 static const char col_gray1[]       = "#222222";
 static const char col_gray2[]       = "#444444";
 static const char col_gray3[]       = "#bbbbbb";
@@ -20,22 +20,40 @@ static const char *colors[][3]      = {
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+static const int taglayouts[] = { 0, 2, 0, 0, 0, 0, 0, 0, 2 };
 
 static const Rule rules[] = {
 	/* xprop(1):
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	/* class      		instance    title       tags mask     	isfloating  monitor */
+	{ "Gimp",     		NULL,       NULL,       0,            	1,          0 },
+	{ "Firefox",  		NULL,       NULL,       1<<1,			0,          0 },
+	{ NULL,  			NULL,       "Mozilla Firefox", 2,		0,          0 },
+	{ "Chromium",  		NULL,       NULL,       1<<1,			0,          0 },
+	{ "Fyne",  			NULL,       NULL,       0,				1,          -1 },
+	{ "Pomodoro",  		NULL,       NULL,       0xFF,			1,          1 },
+	{ "Fynodoro",  		NULL,       NULL,       0xFF,			1,          1 },
+	{ "StreamPanel",  	NULL,       NULL,       0,				1,          1 },
+	{ "pinentry",  		NULL,       NULL,       0,				1,          0 },
+	{ NULL,  			NULL,       "ZynAddSubFX", 1<<7,		1,          0 },
+	{ "Code",  			NULL,       NULL,       1<<0,			0,          0 },
+	{ NULL,  			NULL,       "OBS",      1<<8,			0,          0 },
+	{ NULL,  			NULL,       "Easy Effects", 1<<8,		0,          0 },
+	{ NULL,  			NULL,       "Fullscreen Projector", 1,  0,          3 },
+	{ "Spotify",  		NULL,       NULL,       1<<8,			0,          1 },
+	{ NULL,				NULL,		"A PipeWire Graph Qt GUI Interface", 1<<7, 0, 0 },
+	{ "Logseq",			NULL,		NULL, 		1<<2,			0,			0 },
+	{ "Discord",		NULL,		NULL, 		1<<2,			0,			0 },
+	{ "Bazecor",		NULL,		NULL, 		1<<6,			0,			0 },
+	{ "Element",		NULL,		NULL, 		1<<1,			0,			1 },
 };
 
 /* layout(s) */
 static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
-static const int nmaster     = 1;    /* number of clients in master area */
+static const int nmaster     = 2;    /* number of clients in master area */
 static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
-static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
 
 static const Layout layouts[] = {
 	/* symbol     arrange function */
@@ -46,44 +64,55 @@ static const Layout layouts[] = {
 
 /* key definitions */
 #define MODKEY Mod1Mask
+#define ALTMODKEY (ControlMask|Mod1Mask)
 #define TAGKEYS(KEY,TAG) \
 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
-	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
-	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
-	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+	{ ControlMask|ShiftMask,        KEY,      toggleview,     {.ui = 1 << TAG} }, \
+	{ ALTMODKEY,             		KEY,      tag,            {.ui = 1 << TAG} }, \
+	{ ALTMODKEY|ShiftMask,          KEY,      toggletag,      {.ui = 1 << TAG} },
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
 static const char *dmenucmd[] = { "dmenu_run", "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
-static const char *termcmd[]  = { "x-terminal-emulator", NULL };
+static const char *termcmd[]  = { "alacritty", NULL };
 
 static const Key keys[] = {
 	/* modifier                     key        function        argument */
 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
-	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+	{ ALTMODKEY,             		XK_Return, spawn,          {.v = termcmd } },
 	{ MODKEY,                       XK_b,      togglebar,      {0} },
 	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },	
 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
 	{ MODKEY,                       XK_Return, zoom,           {0} },
 	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+	{ ALTMODKEY,             		XK_c,      killclient,     {0} },
 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
+	{ MODKEY,                       XK_e,      setlayout,      {.v = &layouts[1]} },
 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
 	{ MODKEY,                       XK_space,  setlayout,      {0} },
-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+	{ ALTMODKEY,             		XK_space,  togglefloating, {0} },
+	{ MODKEY,                       XK_f,      togglefullscreen, {0} },
+	{ ALTMODKEY,             		XK_f,      togglefakefullscreen, {0} },
+	//{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+	{ ALTMODKEY,             		XK_0,      tag,            {.ui = ~0 } },
 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
-	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
-	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
-	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+	{ ALTMODKEY,             		XK_comma,  tagmon,         {.i = -1 } },
+	{ ALTMODKEY,             		XK_period, tagmon,         {.i = +1 } },
+	{ ALTMODKEY,             		XK_s,      focusnthmon,    {.ui = 1 } },
+	{ ALTMODKEY,             		XK_d,      focusnthmon,    {.ui = 0 } },
+	{ ALTMODKEY,             		XK_f,      focusnthmon,    {.ui = 3 } },
+	{ ALTMODKEY,             		XK_g,      focusnthmon,    {.ui = 2 } },
+	{ ALTMODKEY|ShiftMask, 			XK_s,      tagnthmon,      {.ui = 1 } },
+	{ ALTMODKEY|ShiftMask, 			XK_d,      tagnthmon,      {.ui = 0 } },
+	{ ALTMODKEY|ShiftMask, 			XK_f,      tagnthmon,      {.ui = 3 } },
+	{ ALTMODKEY|ShiftMask, 			XK_g,      tagnthmon,      {.ui = 2 } },
 	TAGKEYS(                        XK_1,                      0)
 	TAGKEYS(                        XK_2,                      1)
 	TAGKEYS(                        XK_3,                      2)
@@ -93,7 +122,7 @@ static const Key keys[] = {
 	TAGKEYS(                        XK_7,                      6)
 	TAGKEYS(                        XK_8,                      7)
 	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	{ ALTMODKEY,             XK_q,      quit,           {0} },
 };
 
 /* button definitions */
--- dwm-6.4.orig/config.mk
+++ dwm-6.4/config.mk
@@ -25,7 +25,7 @@ LIBS = -lX11 ${XINERAMALIBS} ${FREETYPEL
 # flags
 CPPFLAGS += -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
 #CFLAGS   = -g -std=c99 -pedantic -Wall -O0 ${INCS} ${CPPFLAGS}
-CFLAGS   += -std=c99 -pedantic -Wall -Wno-deprecated-declarations -Os ${INCS} ${CPPFLAGS}
+CFLAGS   += -std=c99 -pedantic -Wall -Wno-deprecated-declarations -Os -g3 ${INCS} ${CPPFLAGS}
 LDFLAGS  += ${LIBS}
 
 # Solaris
--- /dev/null
+++ dwm-6.4/dwm-activemonitor-20230825-e81f17d.diff
@@ -0,0 +1,31 @@
+From 5e8c07dbbf3a2717a1fc852bccc958d789b80540 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Gutyina=20Gerg=C5=91?= <gutyina.gergo.2@gmail.com>
+Date: Thu, 24 Aug 2023 15:39:20 +0200
+Subject: [PATCH] Always show the active monitor with bar color
+
+---
+ dwm.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/dwm.c b/dwm.c
+index f1d86b2..7cd6d4c 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -735,13 +735,12 @@ drawbar(Monitor *m)
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - tw - x) > bh) {
++		drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+ 		if (m->sel) {
+-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+ 			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+ 			if (m->sel->isfloating)
+ 				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+ 		} else {
+-			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+ 		}
+ 	}
+-- 
+2.41.0
+
--- /dev/null
+++ dwm-6.4/dwm-fullscreen-compilation-6.3.diff
@@ -0,0 +1,357 @@
+From 4d2fb76ca3024447fd06407bdc87c09e726f6c27 Mon Sep 17 00:00:00 2001
+From: Bakkeby <bakkeby@gmail.com>
+Date: Mon, 1 Jul 2024 22:14:32 +0200
+Subject: [PATCH] Compilation of fullscreen patches for dwm.
+
+This aims to provide a comprehensive fullscreen solution with the following features:
+   - toggle fullscreen for any window using a single keybinding rather than having
+     to rely on per-application keybindings
+   - the ability to have windows go fullscreen within the size and position the
+     window is currently in (fake fullscreen)
+   - allow a fullscreen window to be moved to an adjacent monitor while remaining
+     fullscreen
+   - make fullscreen windows lose fullscreen if another (e.g. new) window on the
+     same monitor receives focus, while still allowing dialog boxes to show while
+     in fullscreen
+   - allow seamless transition between the two fullscreen modes
+
+The default keybindings are:
+   - MOD+f to make a window fullscreen
+   - MOD+Shift+f to make a window fake fullscreen
+
+This incorporates, and expands on, the following patches:
+   - fakefullscreenclient
+   - togglefullscreen (a.k.a. actualfullscreen)
+   - tagmonfixfs
+   - losefullscreen
+---
+ config.def.h |   5 +-
+ dwm.c        | 176 ++++++++++++++++++++++++++++++++++++++++++---------
+ 2 files changed, 148 insertions(+), 33 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index a2ac963..5f28f2c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -35,7 +35,6 @@ static const Rule rules[] = {
+ static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+-static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+@@ -75,10 +74,12 @@ static Key keys[] = {
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
++	{ MODKEY,                       XK_e,      setlayout,      {.v = &layouts[1]} },
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
++	{ MODKEY,                       XK_f,      togglefullscreen, {0} },
++	{ MODKEY|ShiftMask,             XK_f,      togglefakefullscreen, {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+diff --git a/dwm.c b/dwm.c
+index a96f33c..53f0bd4 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -93,6 +93,7 @@ struct Client {
+ 	int bw, oldbw;
+ 	unsigned int tags;
+ 	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
++	int fakefullscreen;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+@@ -178,6 +179,7 @@ static void grabkeys(void);
+ static void incnmaster(const Arg *arg);
+ static void keypress(XEvent *e);
+ static void killclient(const Arg *arg);
++static void losefullscreen(Client *next);
+ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+@@ -211,7 +213,9 @@ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
++static void togglefakefullscreen(const Arg *arg);
+ static void togglefloating(const Arg *arg);
++static void togglefullscreen(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+@@ -520,9 +524,12 @@ clientmessage(XEvent *e)
+ 		return;
+ 	if (cme->message_type == netatom[NetWMState]) {
+ 		if (cme->data.l[1] == netatom[NetWMFullscreen]
+-		|| cme->data.l[2] == netatom[NetWMFullscreen])
++		|| cme->data.l[2] == netatom[NetWMFullscreen]) {
++			if (c->fakefullscreen == 2 && c->isfullscreen)
++				c->fakefullscreen = 3;
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
++		}
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+@@ -566,7 +573,7 @@ configurenotify(XEvent *e)
+ 			updatebars();
+ 			for (m = mons; m; m = m->next) {
+ 				for (c = m->clients; c; c = c->next)
+-					if (c->isfullscreen)
++					if (c->isfullscreen && c->fakefullscreen != 1)
+ 						resizeclient(c, m->mx, m->my, m->mw, m->mh);
+ 				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+ 			}
+@@ -789,8 +796,10 @@ focus(Client *c)
+ {
+ 	if (!c || !ISVISIBLE(c))
+ 		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
+-	if (selmon->sel && selmon->sel != c)
++	if (selmon->sel && selmon->sel != c) {
++		losefullscreen(c);
+ 		unfocus(selmon->sel, 0);
++	}
+ 	if (c) {
+ 		if (c->mon != selmon)
+ 			selmon = c->mon;
+@@ -838,7 +847,7 @@ focusstack(const Arg *arg)
+ {
+ 	Client *c = NULL, *i;
+ 
+-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
++	if (!selmon->sel || (selmon->sel->isfullscreen && selmon->sel->fakefullscreen != 1))
+ 		return;
+ 	if (arg->i > 0) {
+ 		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+@@ -1018,6 +1027,16 @@ killclient(const Arg *arg)
+ 	}
+ }
+ 
++void
++losefullscreen(Client *next)
++{
++	Client *sel = selmon->sel;
++	if (!sel || !next)
++		return;
++	if (sel->isfullscreen && sel->fakefullscreen != 1 && ISVISIBLE(sel) && sel->mon == next->mon && !next->isfloating)
++		setfullscreen(sel, 0);
++}
++
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+@@ -1072,8 +1091,10 @@ manage(Window w, XWindowAttributes *wa)
+ 		(unsigned char *) &(c->win), 1);
+ 	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
+ 	setclientstate(c, NormalState);
+-	if (c->mon == selmon)
++	if (c->mon == selmon) {
++		losefullscreen(c);
+ 		unfocus(selmon->sel, 0);
++	}
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
+@@ -1147,7 +1168,7 @@ movemouse(const Arg *arg)
+ 
+ 	if (!(c = selmon->sel))
+ 		return;
+-	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
++	if (c->isfullscreen && c->fakefullscreen != 1) /* no support moving fullscreen windows by mouse */
+ 		return;
+ 	restack(selmon);
+ 	ocx = c->x;
+@@ -1302,7 +1323,7 @@ resizemouse(const Arg *arg)
+ 
+ 	if (!(c = selmon->sel))
+ 		return;
+-	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
++	if (c->isfullscreen && c->fakefullscreen != 1) /* no support resizing fullscreen windows by mouse */
+ 		return;
+ 	restack(selmon);
+ 	ocx = c->x;
+@@ -1476,29 +1497,79 @@ setfocus(Client *c)
+ void
+ setfullscreen(Client *c, int fullscreen)
+ {
+-	if (fullscreen && !c->isfullscreen) {
+-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+-			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++	XEvent ev;
++	int savestate = 0, restorestate = 0, restorefakefullscreen = 0;
++
++	if ((c->fakefullscreen == 0 && fullscreen && !c->isfullscreen) // normal fullscreen
++			|| (c->fakefullscreen == 2 && fullscreen)) // fake fullscreen --> actual fullscreen
++		savestate = 1; // go actual fullscreen
++	else if ((c->fakefullscreen == 0 && !fullscreen && c->isfullscreen) // normal fullscreen exit
++			|| (c->fakefullscreen >= 2 && !fullscreen)) // fullscreen exit --> fake fullscreen
++		restorestate = 1; // go back into tiled
++
++	/* If leaving fullscreen and the window was previously fake fullscreen (2), then restore
++	 * that while staying in fullscreen. The exception to this is if we are in said state, but
++	 * the client itself disables fullscreen (3) then we let the client go out of fullscreen
++	 * while keeping fake fullscreen enabled (as otherwise there will be a mismatch between the
++	 * client and the window manager's perception of the client's fullscreen state). */
++	if (c->fakefullscreen == 2 && !fullscreen && c->isfullscreen) {
++		restorefakefullscreen = 1;
+ 		c->isfullscreen = 1;
+-		c->oldstate = c->isfloating;
++		fullscreen = 1;
++	}
++
++	if (fullscreen != c->isfullscreen) { // only send property change if necessary
++		if (fullscreen)
++			XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++				PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
++		else
++			XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
++				PropModeReplace, (unsigned char*)0, 0);
++	}
++
++	c->isfullscreen = fullscreen;
++
++	/* Some clients, e.g. firefox, will send a client message informing the window manager
++	 * that it is going into fullscreen after receiving the above signal. This has the side
++	 * effect of this function (setfullscreen) sometimes being called twice when toggling
++	 * fullscreen on and off via the window manager as opposed to the application itself.
++	 * To protect against obscure issues where the client settings are stored or restored
++	 * when they are not supposed to we add an additional bit-lock on the old state so that
++	 * settings can only be stored and restored in that precise order. */
++	if (savestate && !(c->oldstate & (1 << 1))) {
+ 		c->oldbw = c->bw;
++		c->oldstate = c->isfloating | (1 << 1);
+ 		c->bw = 0;
+ 		c->isfloating = 1;
+ 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+ 		XRaiseWindow(dpy, c->win);
+-	} else if (!fullscreen && c->isfullscreen){
+-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+-			PropModeReplace, (unsigned char*)0, 0);
+-		c->isfullscreen = 0;
+-		c->isfloating = c->oldstate;
++	} else if (restorestate && (c->oldstate & (1 << 1))) {
+ 		c->bw = c->oldbw;
+-		c->x = c->oldx;
+-		c->y = c->oldy;
+-		c->w = c->oldw;
+-		c->h = c->oldh;
++		c->isfloating = c->oldstate = c->oldstate & 1;
++		if (restorefakefullscreen || c->fakefullscreen == 3)
++			c->fakefullscreen = 1;
++		/* The client may have been moved to another monitor whilst in fullscreen which if tiled
++		 * we address by doing a full arrange of tiled clients. If the client is floating then the
++		 * height and width may be larger than the monitor's window area, so we cap that by
++		 * ensuring max / min values. */
++		if (c->isfloating) {
++			c->x = MAX(c->mon->wx, c->oldx);
++			c->y = MAX(c->mon->wy, c->oldy);
++			c->w = MIN(c->mon->ww - c->x - 2*c->bw, c->oldw);
++			c->h = MIN(c->mon->wh - c->y - 2*c->bw, c->oldh);
++			resizeclient(c, c->x, c->y, c->w, c->h);
++			restack(c->mon);
++		} else
++			arrange(c->mon);
++	} else
+ 		resizeclient(c, c->x, c->y, c->w, c->h);
+-		arrange(c->mon);
+-	}
++
++	/* Exception: if the client was in actual fullscreen and we exit out to fake fullscreen
++	 * mode, then the focus would sometimes drift to whichever window is under the mouse cursor
++	 * at the time. To avoid this we ask X for all EnterNotify events and just ignore them.
++	 */
++	if (!c->isfullscreen)
++		while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+ }
+ 
+ void
+@@ -1669,9 +1740,19 @@ tag(const Arg *arg)
+ void
+ tagmon(const Arg *arg)
+ {
+-	if (!selmon->sel || !mons->next)
++	Client *c = selmon->sel;
++	if (!c || !mons->next)
+ 		return;
+-	sendmon(selmon->sel, dirtomon(arg->i));
++	if (c->isfullscreen) {
++		c->isfullscreen = 0;
++		sendmon(c, dirtomon(arg->i));
++		c->isfullscreen = 1;
++		if (c->fakefullscreen != 1) {
++			resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
++			XRaiseWindow(dpy, c->win);
++		}
++	} else
++		sendmon(c, dirtomon(arg->i));
+ }
+ 
+ void
+@@ -1711,18 +1792,51 @@ togglebar(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++togglefakefullscreen(const Arg *arg)
++{
++	Client *c = selmon->sel;
++	if (!c)
++		return;
++
++	if (c->fakefullscreen != 1 && c->isfullscreen) { // exit fullscreen --> fake fullscreen
++		c->fakefullscreen = 2;
++		setfullscreen(c, 0);
++	} else if (c->fakefullscreen == 1) {
++		setfullscreen(c, 0);
++		c->fakefullscreen = 0;
++	} else {
++		c->fakefullscreen = 1;
++		setfullscreen(c, 1);
++	}
++}
++
+ void
+ togglefloating(const Arg *arg)
+ {
+-	if (!selmon->sel)
++	Client *c = selmon->sel;
++	if (!c)
+ 		return;
+-	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
++	if (c->isfullscreen && c->fakefullscreen != 1) /* no support for fullscreen windows */
+ 		return;
+-	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+-	if (selmon->sel->isfloating)
+-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+-			selmon->sel->w, selmon->sel->h, 0);
+-	arrange(selmon);
++	c->isfloating = !c->isfloating || c->isfixed;
++	if (c->isfloating)
++		resize(c, c->x, c->y, c->w, c->h, 0);
++	arrange(c->mon);
++}
++
++void
++togglefullscreen(const Arg *arg)
++{
++	Client *c = selmon->sel;
++	if (!c)
++		return;
++
++	if (c->fakefullscreen == 1) { // fake fullscreen --> fullscreen
++		c->fakefullscreen = 2;
++		setfullscreen(c, 1);
++	} else
++		setfullscreen(c, !c->isfullscreen);
+ }
+ 
+ void
+-- 
+2.45.2
+
--- /dev/null
+++ dwm-6.4/dwm-pertag-20200914-61bb8b2.diff
@@ -0,0 +1,177 @@
+diff --git a/dwm.c b/dwm.c
+index 664c527..ac8e4ec 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -111,6 +111,7 @@ typedef struct {
+ 	void (*arrange)(Monitor *);
+ } Layout;
+ 
++typedef struct Pertag Pertag;
+ struct Monitor {
+ 	char ltsymbol[16];
+ 	float mfact;
+@@ -130,6 +131,7 @@ struct Monitor {
+ 	Monitor *next;
+ 	Window barwin;
+ 	const Layout *lt[2];
++	Pertag *pertag;
+ };
+ 
+ typedef struct {
+@@ -272,6 +274,15 @@ static Window root, wmcheckwin;
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
++struct Pertag {
++	unsigned int curtag, prevtag; /* current and previous tag */
++	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
++	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
++	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
++	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
++	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
++};
++
+ /* compile-time check if all tags fit into an unsigned int bit array. */
+ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ 
+@@ -632,6 +643,7 @@ Monitor *
+ createmon(void)
+ {
+ 	Monitor *m;
++	unsigned int i;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+ 	m->tagset[0] = m->tagset[1] = 1;
+@@ -642,6 +654,20 @@ createmon(void)
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
++	m->pertag = ecalloc(1, sizeof(Pertag));
++	m->pertag->curtag = m->pertag->prevtag = 1;
++
++	for (i = 0; i <= LENGTH(tags); i++) {
++		m->pertag->nmasters[i] = m->nmaster;
++		m->pertag->mfacts[i] = m->mfact;
++
++		m->pertag->ltidxs[i][0] = m->lt[0];
++		m->pertag->ltidxs[i][1] = m->lt[1];
++		m->pertag->sellts[i] = m->sellt;
++
++		m->pertag->showbars[i] = m->showbar;
++	}
++
+ 	return m;
+ }
+ 
+@@ -967,7 +993,7 @@ grabkeys(void)
+ void
+ incnmaster(const Arg *arg)
+ {
+-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+ 	arrange(selmon);
+ }
+ 
+@@ -1502,9 +1528,9 @@ void
+ setlayout(const Arg *arg)
+ {
+ 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+-		selmon->sellt ^= 1;
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+ 	if (arg && arg->v)
+-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+ 	if (selmon->sel)
+ 		arrange(selmon);
+@@ -1523,7 +1549,7 @@ setmfact(const Arg *arg)
+ 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+ 	if (f < 0.05 || f > 0.95)
+ 		return;
+-	selmon->mfact = f;
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+ 	arrange(selmon);
+ }
+ 
+@@ -1702,7 +1728,7 @@ tile(Monitor *m)
+ void
+ togglebar(const Arg *arg)
+ {
+-	selmon->showbar = !selmon->showbar;
++	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
+ 	updatebarpos(selmon);
+ 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+ 	arrange(selmon);
+@@ -1741,9 +1767,33 @@ void
+ toggleview(const Arg *arg)
+ {
+ 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
++	int i;
+ 
+ 	if (newtagset) {
+ 		selmon->tagset[selmon->seltags] = newtagset;
++
++		if (newtagset == ~0) {
++			selmon->pertag->prevtag = selmon->pertag->curtag;
++			selmon->pertag->curtag = 0;
++		}
++
++		/* test if the user did not select the same tag */
++		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
++			selmon->pertag->prevtag = selmon->pertag->curtag;
++			for (i = 0; !(newtagset & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++
++		/* apply settings for this view */
++		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
++		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
++			togglebar(NULL);
++
+ 		focus(NULL);
+ 		arrange(selmon);
+ 	}
+@@ -2038,11 +2088,37 @@ updatewmhints(Client *c)
+ void
+ view(const Arg *arg)
+ {
++	int i;
++	unsigned int tmptag;
++
+ 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+ 		return;
+ 	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
++	if (arg->ui & TAGMASK) {
+ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++
++		if (arg->ui == ~0)
++			selmon->pertag->curtag = 0;
++		else {
++			for (i = 0; !(arg->ui & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++	} else {
++		tmptag = selmon->pertag->prevtag;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++		selmon->pertag->curtag = tmptag;
++	}
++
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
++	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
++		togglebar(NULL);
++
+ 	focus(NULL);
+ 	arrange(selmon);
+ }
--- /dev/null
+++ dwm-6.4/dwm-statusallmons-6.2.diff
@@ -0,0 +1,25 @@
+diff -up a/dwm.c b/dwm.c
+--- a/dwm.c	2020-07-09 16:49:10.023585649 +0200
++++ b/dwm.c	2020-07-09 16:49:43.497542191 +0200
+@@ -702,7 +702,7 @@ drawbar(Monitor *m)
+ 	Client *c;
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+-	if (m == selmon) { /* status is only drawn on selected monitor */
++	if (m == selmon || 1) { /* status is only drawn on selected monitor */
+ 		drw_setscheme(drw, scheme[SchemeNorm]);
+ 		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+ 		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
+@@ -1987,9 +1987,11 @@ updatesizehints(Client *c)
+ void
+ updatestatus(void)
+ {
++	Monitor* m;
+ 	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+ 		strcpy(stext, "dwm-"VERSION);
+-	drawbar(selmon);
++	for(m = mons; m; m = m->next)
++		drawbar(m);
+ }
+ 
+ void
--- /dev/null
+++ dwm-6.4/dwm-taglayouts-6.4.diff
@@ -0,0 +1,50 @@
+diff --git a/config.def.h b/config.def.h
+index 9efa774..2fc0594 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -20,6 +20,7 @@ static const char *colors[][3]      = {
+ 
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
++static const int taglayouts[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+diff --git a/dwm.c b/dwm.c
+index 8655ec4..1506985 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -654,9 +654,6 @@ createmon(void)
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
+-	m->lt[0] = &layouts[0];
+-	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+-	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+ 	m->pertag = ecalloc(1, sizeof(Pertag));
+ 	m->pertag->curtag = m->pertag->prevtag = 1;
+ 
+@@ -664,13 +661,22 @@ createmon(void)
+ 		m->pertag->nmasters[i] = m->nmaster;
+ 		m->pertag->mfacts[i] = m->mfact;
+ 
+-		m->pertag->ltidxs[i][0] = m->lt[0];
++		if (i >= 1) {
++			m->pertag->ltidxs[i][0] = &layouts[taglayouts[i-1]];
++		}
++		else {
++			m->pertag->ltidxs[i][0] = &layouts[0];
++		}
+ 		m->pertag->ltidxs[i][1] = m->lt[1];
+ 		m->pertag->sellts[i] = m->sellt;
+ 
+ 		m->pertag->showbars[i] = m->showbar;
+ 	}
+ 
++	m->lt[0] = m->pertag->ltidxs[1][0];
++	m->lt[1] = &layouts[1 % LENGTH(layouts)];
++	strncpy(m->ltsymbol, m->pertag->ltidxs[1][0]->symbol, sizeof m->ltsymbol);
++
+ 	return m;
+ }
+ 
--- /dev/null
+++ dwm-6.4/dwm-warp-6.4.diff
@@ -0,0 +1,79 @@
+From a229c36f51ad6f8b40109ed53c643f242351962a Mon Sep 17 00:00:00 2001
+From: Jonas Dujava <jonas.dujava@gmail.com>
+Date: Fri, 26 May 2023 22:14:48 +0200
+Subject: [PATCH] Warp patch
+
+Warps the mouse cursor to the center of the currently focused
+window or screen when the mouse cursor is
+  (a) on a different screen, or
+  (b) on top of a different window.
+
+This version properly handles warping to windows that have not been
+mapped yet (before it resulted in a change of the stack order).
+See the discussion in (thanks goes to Bakkeby):
+    https://github.com/bakkeby/patches/issues/60
+---
+ dwm.c | 26 ++++++++++++++++++++++++++
+ 1 file changed, 26 insertions(+)
+
+diff --git a/dwm.c b/dwm.c
+index e5efb6a..7ea6c14 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -228,6 +228,7 @@ static void updatetitle(Client *c);
+ static void updatewindowtype(Client *c);
+ static void updatewmhints(Client *c);
+ static void view(const Arg *arg);
++static void warp(const Client *c);
+ static Client *wintoclient(Window w);
+ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+@@ -834,6 +835,7 @@ focusmon(const Arg *arg)
+ 	unfocus(selmon->sel, 0);
+ 	selmon = m;
+ 	focus(NULL);
++	warp(selmon->sel);
+ }
+ 
+ void
+@@ -1366,6 +1368,8 @@ restack(Monitor *m)
+ 				wc.sibling = c->win;
+ 			}
+ 	}
++	if (m == selmon && (m->tagset[m->seltags] & m->sel->tags) && m->lt[m->sellt]->arrange != &monocle)
++		warp(m->sel);
+ 	XSync(dpy, False);
+ 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+ }
+@@ -2044,6 +2048,28 @@ view(const Arg *arg)
+ 	arrange(selmon);
+ }
+ 
++void
++warp(const Client *c)
++{
++	int x, y;
++
++	if (!c) {
++		XWarpPointer(dpy, None, root, 0, 0, 0, 0, selmon->wx + selmon->ww / 2, selmon->wy + selmon->wh / 2);
++		return;
++	}
++
++	if (!getrootptr(&x, &y) ||
++		(x > c->x - c->bw &&
++		 y > c->y - c->bw &&
++		 x < c->x + c->w + c->bw*2 &&
++		 y < c->y + c->h + c->bw*2) ||
++		(y > c->mon->by && y < c->mon->by + bh) ||
++		(c->mon->topbar && !y))
++		return;
++
++	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w / 2, c->h / 2);
++}
++
+ Client *
+ wintoclient(Window w)
+ {
+-- 
+2.40.1
+
--- /dev/null
+++ dwm-6.4/dwm-windowmap-20221026.diff
@@ -0,0 +1,83 @@
+diff --git a/dwm.c b/dwm.c
+index e5efb6a..eaf0333 100644
+--- a/dwm.c
++++ b/dwm.c
+@@ -228,6 +228,9 @@ static void updatetitle(Client *c);
+ static void updatewindowtype(Client *c);
+ static void updatewmhints(Client *c);
+ static void view(const Arg *arg);
++static void window_set_state(Display *dpy, Window win, long state);
++static void window_map(Display *dpy, Client *c, int deiconify);
++static void window_unmap(Display *dpy, Window win, Window root, int iconify);
+ static Client *wintoclient(Window w);
+ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+@@ -1617,14 +1620,12 @@ showhide(Client *c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
+ 		/* show clients top down */
+-		XMoveWindow(dpy, c->win, c->x, c->y);
+-		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+-			resize(c, c->x, c->y, c->w, c->h, 0);
++		window_map(dpy, c, 1);
+ 		showhide(c->snext);
+ 	} else {
+ 		/* hide clients bottom up */
+ 		showhide(c->snext);
+-		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
++		window_unmap(dpy, c->win, root, 1);
+ 	}
+ }
+ 
+@@ -2032,6 +2033,51 @@ updatewmhints(Client *c)
+ 	}
+ }
+ 
++void
++window_set_state(Display *dpy, Window win, long state)
++{
++	long data[] = { state, None };
++
++	XChangeProperty(dpy, win, wmatom[WMState], wmatom[WMState], 32,
++		PropModeReplace, (unsigned char*)data, 2);
++}
++
++void
++window_map(Display *dpy, Client *c, int deiconify)
++{
++	Window win = c->win;
++
++	if (deiconify)
++		window_set_state(dpy, win, NormalState);
++
++	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
++	XSetInputFocus(dpy, win, RevertToPointerRoot, CurrentTime);
++	XMapWindow(dpy, win);
++}
++
++void
++window_unmap(Display *dpy, Window win, Window root, int iconify)
++{
++	static XWindowAttributes ca, ra;
++
++	XGrabServer(dpy);
++	XGetWindowAttributes(dpy, root, &ra);
++	XGetWindowAttributes(dpy, win, &ca);
++
++	/* Prevent UnmapNotify events */
++	XSelectInput(dpy, root, ra.your_event_mask & ~SubstructureNotifyMask);
++	XSelectInput(dpy, win, ca.your_event_mask & ~StructureNotifyMask);
++
++	XUnmapWindow(dpy, win);
++
++	if (iconify)
++		window_set_state(dpy, win, IconicState);
++
++	XSelectInput(dpy, root, ra.your_event_mask);
++	XSelectInput(dpy, win, ca.your_event_mask);
++	XUngrabServer(dpy);
++}
++
+ void
+ view(const Arg *arg)
+ {
--- dwm-6.4.orig/dwm.c
+++ dwm-6.4/dwm.c
@@ -93,6 +93,7 @@ struct Client {
 	int bw, oldbw;
 	unsigned int tags;
 	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+	int fakefullscreen;
 	Client *next;
 	Client *snext;
 	Monitor *mon;
@@ -111,6 +112,7 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct Pertag Pertag;
 struct Monitor {
 	char ltsymbol[16];
 	float mfact;
@@ -130,6 +132,7 @@ struct Monitor {
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
+	Pertag *pertag;
 };
 
 typedef struct {
@@ -161,6 +164,7 @@ static void destroynotify(XEvent *e);
 static void detach(Client *c);
 static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
+static Monitor *numtomon(int num);
 static void drawbar(Monitor *m);
 static void drawbars(void);
 static void enternotify(XEvent *e);
@@ -168,6 +172,7 @@ static void expose(XEvent *e);
 static void focus(Client *c);
 static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
+static void focusnthmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
 static int getrootptr(int *x, int *y);
@@ -178,6 +183,7 @@ static void grabkeys(void);
 static void incnmaster(const Arg *arg);
 static void keypress(XEvent *e);
 static void killclient(const Arg *arg);
+static void losefullscreen(Client *next);
 static void manage(Window w, XWindowAttributes *wa);
 static void mappingnotify(XEvent *e);
 static void maprequest(XEvent *e);
@@ -209,9 +215,12 @@ static void sigchld(int unused);
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
+static void tagnthmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglebar(const Arg *arg);
+static void togglefakefullscreen(const Arg *arg);
 static void togglefloating(const Arg *arg);
+static void togglefullscreen(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unfocus(Client *c, int setfocus);
@@ -228,6 +237,10 @@ static void updatetitle(Client *c);
 static void updatewindowtype(Client *c);
 static void updatewmhints(Client *c);
 static void view(const Arg *arg);
+static void window_set_state(Display *dpy, Window win, long state);
+static void window_map(Display *dpy, Client *c, int deiconify);
+static void window_unmap(Display *dpy, Window win, Window root, int iconify);
+static void warp(const Client *c);
 static Client *wintoclient(Window w);
 static Monitor *wintomon(Window w);
 static int xerror(Display *dpy, XErrorEvent *ee);
@@ -272,6 +285,15 @@ static Window root, wmcheckwin;
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+struct Pertag {
+	unsigned int curtag, prevtag; /* current and previous tag */
+	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+};
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -523,9 +545,12 @@ clientmessage(XEvent *e)
 		return;
 	if (cme->message_type == netatom[NetWMState]) {
 		if (cme->data.l[1] == netatom[NetWMFullscreen]
-		|| cme->data.l[2] == netatom[NetWMFullscreen])
+		|| cme->data.l[2] == netatom[NetWMFullscreen]) {
+			if (c->fakefullscreen == 2 && c->isfullscreen)
+				c->fakefullscreen = 3;
 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+		}
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
@@ -569,7 +594,7 @@ configurenotify(XEvent *e)
 			updatebars();
 			for (m = mons; m; m = m->next) {
 				for (c = m->clients; c; c = c->next)
-					if (c->isfullscreen)
+					if (c->isfullscreen && c->fakefullscreen != 1)
 						resizeclient(c, m->mx, m->my, m->mw, m->mh);
 				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
 			}
@@ -635,6 +660,7 @@ Monitor *
 createmon(void)
 {
 	Monitor *m;
+	unsigned int i;
 
 	m = ecalloc(1, sizeof(Monitor));
 	m->tagset[0] = m->tagset[1] = 1;
@@ -642,9 +668,29 @@ createmon(void)
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
-	m->lt[0] = &layouts[0];
+	m->pertag = ecalloc(1, sizeof(Pertag));
+	m->pertag->curtag = m->pertag->prevtag = 1;
+
+	for (i = 0; i <= LENGTH(tags); i++) {
+		m->pertag->nmasters[i] = m->nmaster;
+		m->pertag->mfacts[i] = m->mfact;
+
+		if (i >= 1) {
+			m->pertag->ltidxs[i][0] = &layouts[taglayouts[i-1]];
+		}
+		else {
+			m->pertag->ltidxs[i][0] = &layouts[0];
+		}
+		m->pertag->ltidxs[i][1] = m->lt[1];
+		m->pertag->sellts[i] = m->sellt;
+
+		m->pertag->showbars[i] = m->showbar;
+	}
+
+	m->lt[0] = m->pertag->ltidxs[1][0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
-	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	strncpy(m->ltsymbol, m->pertag->ltidxs[1][0]->symbol, sizeof m->ltsymbol);
+
 	return m;
 }
 
@@ -696,6 +742,18 @@ dirtomon(int dir)
 	return m;
 }
 
+Monitor *
+numtomon(int num)
+{
+	Monitor *m = NULL;
+	int i = 0;
+
+	for(m = mons, i=0; m->next && i < num; m = m->next){
+		i++;
+	}
+	return m;
+}
+
 void
 drawbar(Monitor *m)
 {
@@ -709,7 +767,7 @@ drawbar(Monitor *m)
 		return;
 
 	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
+	if (m == selmon || 1) { /* status is only drawn on selected monitor */
 		drw_setscheme(drw, scheme[SchemeNorm]);
 		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
 		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
@@ -736,13 +794,12 @@ drawbar(Monitor *m)
 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
 
 	if ((w = m->ww - tw - x) > bh) {
+		drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
 		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
 			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
 			if (m->sel->isfloating)
 				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
 		} else {
-			drw_setscheme(drw, scheme[SchemeNorm]);
 			drw_rect(drw, x, 0, w, bh, 1, 1);
 		}
 	}
@@ -792,8 +849,10 @@ focus(Client *c)
 {
 	if (!c || !ISVISIBLE(c))
 		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
-	if (selmon->sel && selmon->sel != c)
+	if (selmon->sel && selmon->sel != c) {
+		losefullscreen(c);
 		unfocus(selmon->sel, 0);
+	}
 	if (c) {
 		if (c->mon != selmon)
 			selmon = c->mon;
@@ -834,6 +893,23 @@ focusmon(const Arg *arg)
 	unfocus(selmon->sel, 0);
 	selmon = m;
 	focus(NULL);
+	warp(selmon->sel);
+}
+
+void
+focusnthmon(const Arg *arg)
+{
+	Monitor *m;
+
+	if (!mons->next)
+		return;
+
+	if ((m = numtomon(arg->i)) == selmon)
+		return;
+	unfocus(selmon->sel, 0);
+	selmon = m;
+	focus(NULL);
+	warp(selmon->sel);
 }
 
 void
@@ -841,7 +917,7 @@ focusstack(const Arg *arg)
 {
 	Client *c = NULL, *i;
 
-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
+	if (!selmon->sel || (selmon->sel->isfullscreen && selmon->sel->fakefullscreen != 1))
 		return;
 	if (arg->i > 0) {
 		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
@@ -971,7 +1047,7 @@ grabkeys(void)
 void
 incnmaster(const Arg *arg)
 {
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
 	arrange(selmon);
 }
 
@@ -1020,6 +1096,16 @@ killclient(const Arg *arg)
 }
 
 void
+losefullscreen(Client *next)
+{
+	Client *sel = selmon->sel;
+	if (!sel || !next)
+		return;
+	if (sel->isfullscreen && sel->fakefullscreen != 1 && ISVISIBLE(sel) && sel->mon == next->mon && !next->isfloating)
+		setfullscreen(sel, 0);
+}
+
+void
 manage(Window w, XWindowAttributes *wa)
 {
 	Client *c, *t = NULL;
@@ -1071,8 +1157,10 @@ manage(Window w, XWindowAttributes *wa)
 		(unsigned char *) &(c->win), 1);
 	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
 	setclientstate(c, NormalState);
-	if (c->mon == selmon)
+	if (c->mon == selmon) {
+		losefullscreen(c);
 		unfocus(selmon->sel, 0);
+	}
 	c->mon->sel = c;
 	arrange(c->mon);
 	XMapWindow(dpy, c->win);
@@ -1144,7 +1232,7 @@ movemouse(const Arg *arg)
 
 	if (!(c = selmon->sel))
 		return;
-	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+	if (c->isfullscreen && c->fakefullscreen != 1) /* no support moving fullscreen windows by mouse */
 		return;
 	restack(selmon);
 	ocx = c->x;
@@ -1299,7 +1387,7 @@ resizemouse(const Arg *arg)
 
 	if (!(c = selmon->sel))
 		return;
-	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+	if (c->isfullscreen && c->fakefullscreen != 1) /* no support resizing fullscreen windows by mouse */
 		return;
 	restack(selmon);
 	ocx = c->x;
@@ -1366,6 +1454,8 @@ restack(Monitor *m)
 				wc.sibling = c->win;
 			}
 	}
+	if (m == selmon && (m->tagset[m->seltags] & m->sel->tags) && m->lt[m->sellt]->arrange != &monocle)
+		warp(m->sel);
 	XSync(dpy, False);
 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
 }
@@ -1422,6 +1512,9 @@ sendmon(Client *c, Monitor *m)
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
+	focus(c);
+	restack(selmon);
+	warp(c);
 }
 
 void
@@ -1473,38 +1566,88 @@ setfocus(Client *c)
 void
 setfullscreen(Client *c, int fullscreen)
 {
-	if (fullscreen && !c->isfullscreen) {
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+	XEvent ev;
+	int savestate = 0, restorestate = 0, restorefakefullscreen = 0;
+
+	if ((c->fakefullscreen == 0 && fullscreen && !c->isfullscreen) // normal fullscreen
+			|| (c->fakefullscreen == 2 && fullscreen)) // fake fullscreen --> actual fullscreen
+		savestate = 1; // go actual fullscreen
+	else if ((c->fakefullscreen == 0 && !fullscreen && c->isfullscreen) // normal fullscreen exit
+			|| (c->fakefullscreen >= 2 && !fullscreen)) // fullscreen exit --> fake fullscreen
+		restorestate = 1; // go back into tiled
+
+	/* If leaving fullscreen and the window was previously fake fullscreen (2), then restore
+	 * that while staying in fullscreen. The exception to this is if we are in said state, but
+	 * the client itself disables fullscreen (3) then we let the client go out of fullscreen
+	 * while keeping fake fullscreen enabled (as otherwise there will be a mismatch between the
+	 * client and the window manager's perception of the client's fullscreen state). */
+	if (c->fakefullscreen == 2 && !fullscreen && c->isfullscreen) {
+		restorefakefullscreen = 1;
 		c->isfullscreen = 1;
-		c->oldstate = c->isfloating;
+		fullscreen = 1;
+	}
+
+	if (fullscreen != c->isfullscreen) { // only send property change if necessary
+		if (fullscreen)
+			XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+				PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+		else
+			XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+				PropModeReplace, (unsigned char*)0, 0);
+	}
+
+	c->isfullscreen = fullscreen;
+
+	/* Some clients, e.g. firefox, will send a client message informing the window manager
+	 * that it is going into fullscreen after receiving the above signal. This has the side
+	 * effect of this function (setfullscreen) sometimes being called twice when toggling
+	 * fullscreen on and off via the window manager as opposed to the application itself.
+	 * To protect against obscure issues where the client settings are stored or restored
+	 * when they are not supposed to we add an additional bit-lock on the old state so that
+	 * settings can only be stored and restored in that precise order. */
+	if (savestate && !(c->oldstate & (1 << 1))) {
 		c->oldbw = c->bw;
+		c->oldstate = c->isfloating | (1 << 1);
 		c->bw = 0;
 		c->isfloating = 1;
 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
 		XRaiseWindow(dpy, c->win);
-	} else if (!fullscreen && c->isfullscreen){
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)0, 0);
-		c->isfullscreen = 0;
-		c->isfloating = c->oldstate;
+	} else if (restorestate && (c->oldstate & (1 << 1))) {
 		c->bw = c->oldbw;
-		c->x = c->oldx;
-		c->y = c->oldy;
-		c->w = c->oldw;
-		c->h = c->oldh;
+		c->isfloating = c->oldstate = c->oldstate & 1;
+		if (restorefakefullscreen || c->fakefullscreen == 3)
+			c->fakefullscreen = 1;
+		/* The client may have been moved to another monitor whilst in fullscreen which if tiled
+		 * we address by doing a full arrange of tiled clients. If the client is floating then the
+		 * height and width may be larger than the monitor's window area, so we cap that by
+		 * ensuring max / min values. */
+		if (c->isfloating) {
+			c->x = MAX(c->mon->wx, c->oldx);
+			c->y = MAX(c->mon->wy, c->oldy);
+			c->w = MIN(c->mon->ww - c->x - 2*c->bw, c->oldw);
+			c->h = MIN(c->mon->wh - c->y - 2*c->bw, c->oldh);
+			resizeclient(c, c->x, c->y, c->w, c->h);
+			restack(c->mon);
+		} else
+			arrange(c->mon);
+	} else
 		resizeclient(c, c->x, c->y, c->w, c->h);
-		arrange(c->mon);
-	}
+
+	/* Exception: if the client was in actual fullscreen and we exit out to fake fullscreen
+	 * mode, then the focus would sometimes drift to whichever window is under the mouse cursor
+	 * at the time. To avoid this we ask X for all EnterNotify events and just ignore them.
+	 */
+	if (!c->isfullscreen)
+		while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
 }
 
 void
 setlayout(const Arg *arg)
 {
 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
 	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
 	if (selmon->sel)
 		arrange(selmon);
@@ -1523,7 +1666,7 @@ setmfact(const Arg *arg)
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.05 || f > 0.95)
 		return;
-	selmon->mfact = f;
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
 	arrange(selmon);
 }
 
@@ -1617,14 +1760,12 @@ showhide(Client *c)
 		return;
 	if (ISVISIBLE(c)) {
 		/* show clients top down */
-		XMoveWindow(dpy, c->win, c->x, c->y);
-		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
-			resize(c, c->x, c->y, c->w, c->h, 0);
+		window_map(dpy, c, 1);
 		showhide(c->snext);
 	} else {
 		/* hide clients bottom up */
 		showhide(c->snext);
-		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+		window_unmap(dpy, c->win, root, 1);
 	}
 }
 
@@ -1661,9 +1802,27 @@ tag(const Arg *arg)
 void
 tagmon(const Arg *arg)
 {
+	Client *c = selmon->sel;
+	if (!c || !mons->next)
+		return;
+	if (c->isfullscreen) {
+		c->isfullscreen = 0;
+		sendmon(c, dirtomon(arg->i));
+		c->isfullscreen = 1;
+		if (c->fakefullscreen != 1) {
+			resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+			XRaiseWindow(dpy, c->win);
+		}
+	} else
+		sendmon(c, dirtomon(arg->i));
+}
+
+void
+tagnthmon(const Arg *arg)
+{
 	if (!selmon->sel || !mons->next)
 		return;
-	sendmon(selmon->sel, dirtomon(arg->i));
+	sendmon(selmon->sel, numtomon(arg->i));
 }
 
 void
@@ -1697,24 +1856,57 @@ tile(Monitor *m)
 void
 togglebar(const Arg *arg)
 {
-	selmon->showbar = !selmon->showbar;
+	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
 	updatebarpos(selmon);
 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
 	arrange(selmon);
 }
 
 void
+togglefakefullscreen(const Arg *arg)
+{
+	Client *c = selmon->sel;
+	if (!c)
+		return;
+
+	if (c->fakefullscreen != 1 && c->isfullscreen) { // exit fullscreen --> fake fullscreen
+		c->fakefullscreen = 2;
+		setfullscreen(c, 0);
+	} else if (c->fakefullscreen == 1) {
+		setfullscreen(c, 0);
+		c->fakefullscreen = 0;
+	} else {
+		c->fakefullscreen = 1;
+		setfullscreen(c, 1);
+	}
+}
+
+void
 togglefloating(const Arg *arg)
 {
-	if (!selmon->sel)
+	Client *c = selmon->sel;
+	if (!c)
 		return;
-	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+	if (c->isfullscreen && c->fakefullscreen != 1) /* no support for fullscreen windows */
 		return;
-	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-	if (selmon->sel->isfloating)
-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
-			selmon->sel->w, selmon->sel->h, 0);
-	arrange(selmon);
+	c->isfloating = !c->isfloating || c->isfixed;
+	if (c->isfloating)
+		resize(c, c->x, c->y, c->w, c->h, 0);
+	arrange(c->mon);
+}
+
+void
+togglefullscreen(const Arg *arg)
+{
+	Client *c = selmon->sel;
+	if (!c)
+		return;
+
+	if (c->fakefullscreen == 1) { // fake fullscreen --> fullscreen
+		c->fakefullscreen = 2;
+		setfullscreen(c, 1);
+	} else
+		setfullscreen(c, !c->isfullscreen);
 }
 
 void
@@ -1736,9 +1928,33 @@ void
 toggleview(const Arg *arg)
 {
 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+	int i;
 
 	if (newtagset) {
 		selmon->tagset[selmon->seltags] = newtagset;
+
+		if (newtagset == ~0) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			selmon->pertag->curtag = 0;
+		}
+
+		/* test if the user did not select the same tag */
+		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			for (i = 0; !(newtagset & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+
+		/* apply settings for this view */
+		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
+		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+			togglebar(NULL);
+
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -1987,9 +2203,11 @@ updatesizehints(Client *c)
 void
 updatestatus(void)
 {
+	Monitor* m;
 	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
 		strcpy(stext, "dwm-"VERSION);
-	drawbar(selmon);
+	for(m = mons; m; m = m->next)
+		drawbar(m);
 }
 
 void
@@ -2033,17 +2251,110 @@ updatewmhints(Client *c)
 }
 
 void
+window_set_state(Display *dpy, Window win, long state)
+{
+	long data[] = { state, None };
+
+	XChangeProperty(dpy, win, wmatom[WMState], wmatom[WMState], 32,
+		PropModeReplace, (unsigned char*)data, 2);
+}
+
+void
+window_map(Display *dpy, Client *c, int deiconify)
+{
+	Window win = c->win;
+
+	if (deiconify)
+		window_set_state(dpy, win, NormalState);
+
+	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+	XSetInputFocus(dpy, win, RevertToPointerRoot, CurrentTime);
+	XMapWindow(dpy, win);
+}
+
+void
+window_unmap(Display *dpy, Window win, Window root, int iconify)
+{
+	static XWindowAttributes ca, ra;
+
+	XGrabServer(dpy);
+	XGetWindowAttributes(dpy, root, &ra);
+	XGetWindowAttributes(dpy, win, &ca);
+
+	/* Prevent UnmapNotify events */
+	XSelectInput(dpy, root, ra.your_event_mask & ~SubstructureNotifyMask);
+	XSelectInput(dpy, win, ca.your_event_mask & ~StructureNotifyMask);
+
+	XUnmapWindow(dpy, win);
+
+	if (iconify)
+		window_set_state(dpy, win, IconicState);
+
+	XSelectInput(dpy, root, ra.your_event_mask);
+	XSelectInput(dpy, win, ca.your_event_mask);
+	XUngrabServer(dpy);
+}
+
+void
 view(const Arg *arg)
 {
+	int i;
+	unsigned int tmptag;
+
 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
+	if (arg->ui & TAGMASK) {
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+
+		if (arg->ui == ~0)
+			selmon->pertag->curtag = 0;
+		else {
+			for (i = 0; !(arg->ui & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+	} else {
+		tmptag = selmon->pertag->prevtag;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		selmon->pertag->curtag = tmptag;
+	}
+
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
+	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+		togglebar(NULL);
+
 	focus(NULL);
 	arrange(selmon);
 }
 
+void
+warp(const Client *c)
+{
+	int x, y;
+
+	if (!c) {
+		XWarpPointer(dpy, None, root, 0, 0, 0, 0, selmon->wx + selmon->ww / 2, selmon->wy + selmon->wh / 2);
+		return;
+	}
+
+	if (!getrootptr(&x, &y) ||
+		(x > c->x - c->bw &&
+		 y > c->y - c->bw &&
+		 x < c->x + c->w + c->bw*2 &&
+		 y < c->y + c->h + c->bw*2) ||
+		(y > c->mon->by && y < c->mon->by + bh) ||
+		(c->mon->topbar && !y))
+		return;
+
+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w / 2, c->h / 2);
+}
+
 Client *
 wintoclient(Window w)
 {
--- /dev/null
+++ dwm-6.4/update-dwm.sh
@@ -0,0 +1 @@
+cp config.def.h config.h; make && ( sudo mv /usr/bin/dwm.default /usr/bin/dwm.default-todelete; sudo cp dwm /usr/bin/dwm.default; kill "$(ps auxw | grep dwm | grep '/usr/bin/dw[m]' | awk '{print $2}')"; sleep 1; sudo rm -f /usr/bin/dwm.default-todelete )
